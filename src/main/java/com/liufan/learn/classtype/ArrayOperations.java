package com.liufan.learn.classtype;

import java.util.Arrays;

/**
 * 数组操作
 */
public class ArrayOperations extends LearnArray {

    /**
     * 打印数组内容
     */
    public static void print() {
        int[] ns = { 1, 1, 2, 3, 5, 8 };

        // 方式一、可以拿到索引
//        for (int i = 0; i < ns.length; i++) {
//            int n = ns[i];
//            System.out.println(n);
//        }

        // 方式二、只能直接取到元素
        for (int n : ns) {
            System.out.println(n);
        }

        // 快速打印数组内容
        System.out.println(Arrays.toString(ns));
    }

    /**
     * 排序
     * <p>
     * 对数组进行排序是程序中非常基本的需求。常用的排序算法有冒泡排序、插入排序和快速排序等。
     */
    public static void sorts() {
        // 冒泡排序算法
        int[] ns = { 28, 12, 89, 73, 65, 18, 96, 50, 8, 36 };
        System.out.println(Arrays.toString(ns)); // 排序前
//        bubbleSorts(ns);
        Arrays.sort(ns);
        System.out.println(Arrays.toString(ns)); // 排序后
        /*
        ⚠️必须注意，对数组排序实际上修改了数组本身。
        int[] ns = { 9, 3, 6, 5 };
              ┌───┬───┬───┬───┐
        ns───▶│ 9 │ 3 │ 6 │ 5 │
              └───┴───┴───┴───┘

        当我们调用 Arrays.sort(ns); 后，这个整型数组在内存中变为：
              ┌───┬───┬───┬───┐
        ns───▶│ 3 │ 5 │ 6 │ 9 │
              └───┴───┴───┴───┘
        即变量 ns 指向的数组内容已经被改变了。

        ⚠️如果对一个字符串数组进行排序，例如：
        String[] ns = { "banana", "apple", "pear" };
                           ┌──────────────────────────────────┐
                       ┌───┼──────────────────────┐           │
                       │   │                      ▼           ▼
                 ┌───┬─┴─┬─┴─┬───┬────────┬───┬───────┬───┬──────┬───┐
        ns ─────▶│░░░│░░░│░░░│   │"banana"│   │"apple"│   │"pear"│   │
                 └─┬─┴───┴───┴───┴────────┴───┴───────┴───┴──────┴───┘
                   │                 ▲
                   └─────────────────┘

        调用 Arrays.sort(ns); 排序后，这个数组在内存中表示如下：
                           ┌──────────────────────────────────┐
                       ┌───┼──────────┐                       │
                       │   │          ▼                       ▼
                 ┌───┬─┴─┬─┴─┬───┬────────┬───┬───────┬───┬──────┬───┐
        ns ─────▶│░░░│░░░│░░░│   │"banana"│   │"apple"│   │"pear"│   │
                 └─┬─┴───┴───┴───┴────────┴───┴───────┴───┴──────┴───┘
                   │                              ▲
                   └──────────────────────────────┘
        原来的 3 个字符串在内存中均没有任何变化，但是 ns 数组的每个元素指向变化了。
         */
    }

    /**
     * 冒泡排序
     */
    public static void bubbleSorts(int[] ns) {
        boolean hasSwap; // 标记本轮是否发生交换（优化点）
        /*
        外 层 循 环 ：控制排序轮数（最多需要 n-1 轮）
        原        理：数组有 n 个元素，最多需要 n-1 轮排序（例如：2 个元素只需 1 轮，3 个元素最多 2 轮）；
                     每轮将未排序的最大元素放到末尾，已排序元素无需再比较。
        变量 i 的含义：表示已完成排序的元素个数（每轮结束后，末尾多 1 个有序元素）
         */
        for (int i = 0; i < ns.length - 1; i++) {
            hasSwap = false; // 初始化：默认本轮未发生交换
            /*
            内 层 循 环 ：核心比较与交换
            原        理：每轮只需遍历未排序的前半部分（末尾 i 个元素已有序，无需比较）；
            变量 j 的含义：遍历未排序部分的索引，每次比较arr[j]和arr[j+1]；
             */
            for (int j = 0; j < ns.length - i - 1; j++) {
                if (ns[j] > ns[j+1]) { // 改成 < 就是降序排序
                    // 交换 ns[j] 和 ns[j+1]
                    int tmp = ns[j];
                    ns[j] = ns[j+1];
                    ns[j+1] = tmp;
                    hasSwap = true; // 标记本轮发生了交换
                }
            }
            if (!hasSwap) {
                /*
                若本轮无交换，说明数组已完全有序，直接退出循环
                场景：若某一轮遍历中没有发生任何交换，说明数组已完全有序（例如：数组 [8,12,18,28,36,50,65,73,89,96]）
                作用：避免后续不必要的轮次。
                 */
                break;
            }
        }
    }
}
