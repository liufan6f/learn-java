package com.liufan.learn;

/**
 * 整型（整数类型）
 * <p>
 * Java 只定义了带符号的整型，因此，最高位的 bit 表示符号位（0 表示正数，1 表示负数）。各种整型能表示的最大范围：
 * <ul>
 *     <li>byte：-128~127</li>
 *     <li>short：-32768~32767</li>
 *     <li>int：-2147483648~2147483647</li>
 *     <li>long：-9223372036854775808~9223372036854775807</li>
 * </ul>
 * <i>
 *     n 代表字节数，最大范围计算公式：-2的(n*8-1)次方 ~ 2的(n*8-1)次方-1
 * </i>
 * @see BasicDataInteger.Arithmetic
 */
class BasicDataInteger extends BasicData {

    static void practice() {
        int i = 2_000_000_000;
        int i2 = -2_000_000_000;        // 加下划线更容易识别
        int i3 = 0b1000000000;          // 二进制表示的 512
        int i4 = 0xff0000;              // 十六进制表示的 16711680
        System.out.println(i);
        System.out.println(i2);
        System.out.println(i3);
        System.out.println(i4);

        long n1 = 9000000000000000000L; // long 型的结尾需要加 L
        long n2 = 900; // 没有加 L，此处 900 为 int，但 int 类型可以赋值给 long
        // int i5 = 900L; // 报错：不能把 long 型赋值给 int
        System.out.println(n1);
        System.out.println(n2);
    }

    /**
     * 整数运算
     * <ul>
     *     <li>整数的数值是精确的，整数运算也是精确的，即使是除法也是精确的，因为两个整数相除只能得到结果的整数部分；</li>
     *     <li>整数存在范围限制，如果计算应该选择合适范围的整型（int 或 long），没有必要为了节省内存而使用 byte 和 short。</li>
     * </ul>
     * @see BasicDataInteger.Arithmetic#numericOverflow()
     */
    static class Arithmetic {

        /**
         * 四则运算
         */
        static void fourFundamentalRules() {
            // Java 的整数运算遵循四则运算规则，可以使用任意嵌套的小括号。四则运算规则和初等数学一致。
            int i = (100 + 200) * (99 - 88); // 3300
            int n = 7 * (5 + (i - 9));       // 23072
            System.out.println(i);
            System.out.println(n);

            int a = 12345;
            int x = a / 67;              // 184
            int y = a % 67;              // 12345÷67 的余数是 17
            // int z = a / 0;            // 整数的除法对于除数为 0 时运行时将报错，但编译不会报错。
            System.out.println(x);
            System.out.println(y);

            // 简写运算符
            i += 100; // i = i + 100;
            System.out.println(i);
            i -= 100; // i = i - 100;
            System.out.println(i);
            i *= 100; // i = i * 100;
            System.out.println(i);
            i /= 100; // i = i / 100;
            System.out.println(i);
            a %= 67; // a = a % 67;
            System.out.println(a);

            // 自增/自减，在 for 循环中普遍使用
            // 注意 ++ 写在前面和后面计算结果是不同的， ++n 表示先加 1 再引用 n， n++ 表示先引用 n 再加 1。
            int b = 5;
            b++; // b = b + 1;
            System.out.println(b);
            b--; // b = b - 1;
            System.out.println(b);
            int c = 100 + (++b); // 不要把 ++ 运算混入到常规运算中，容易自己把自己搞懵了。
            System.out.println(c);
        }

        /**
         * 数值溢出
         * <p>
         * 整数存在范围限制，如果计算结果超出了范围，就会产生溢出，而溢出不会报错，却会得到一个奇怪的结果。
         */
        static void numericOverflow() {
            int x = 2147483640;
            int y = 15;
            int sum = x + y;
            System.out.println(sum); // -2147483641

            /*
            要解释上述结果，我们把整数 2147483640 和 15 换成二进制做加法：

              0111 1111 1111 1111 1111 1111 1111 1000
            + 0000 0000 0000 0000 0000 0000 0000 1111
            -----------------------------------------
              1000 0000 0000 0000 0000 0000 0000 0111 由于最高位计算结果为 1，因此，加法结果变成了一个负数。

             要解决上面的问题，可以把 int 换成 long 类型，由于 long 可表示的整型范围更大，所以结果就不会溢出。
             */

            double a = 2147483640;
            double b = 15;
            double ab = a + b;
            System.out.println(ab); // 2147483655
        }

        /**
         * 移位运算
         * <p>
         * 对 byte 和 short 类型进行移位时，会首先转换为 int 再进行位移。
         */
        static void shiftOperation() {
            // 左移，实际上就是不断地 ×2
            // 在计算机中，整数总是以二进制的形式表示。例如，int 类型的整数 7 使用 4 字节表示的二进制如下
            int n = 7;       // 00000000 00000000 00000000 00000111 = 7
            int a = n << 1;  // 00000000 00000000 00000000 00001110 = 14
            int b = n << 2;  // 00000000 00000000 00000000 00011100 = 28
            int c = n << 28; // 01110000 00000000 00000000 00000000 = 1879048192
            int d = n << 29; // 11100000 00000000 00000000 00000000 = -536870912
            System.out.println(a);
            System.out.println(b);
            System.out.println(c);
            System.out.println(d);

            // 右移，实际上就是不断地 ÷2
            int e = n >> 1;  // 00000000 00000000 00000000 00000011 = 3
            int f = n >> 2;  // 00000000 00000000 00000000 00000001 = 1
            System.out.println(7 / 4);
//            int g = n >> 3;  // 00000000 00000000 00000000 00000000 = 0
            System.out.println(e);
            System.out.println(f);

            // 负数右移，最高位的 1 不动
            // d             // 11100000 00000000 00000000 00000000 = -536870912
            int h = d >> 1;  // 11110000 00000000 00000000 00000000 = -268435456
            int i = d >> 2;  // 11111000 00000000 00000000 00000000 = -134217728
            int j = d >> 28; // 11111111 11111111 11111111 11111110 = -2
            int k = d >> 29; // 11111111 11111111 11111111 11111111 = -1
            System.out.println(h);
            System.out.println(i);
            System.out.println(j);
            System.out.println(Integer.toBinaryString(k) + " = " + k);

            /*
            为什么 11111111 11111111 11111111 11111111 = -1 ？
            要理解这个问题，首先要明确 Java 中整数的编码规则：
            一、原码：最直观的编码方式，最高位是符号位（0 = 正，1 = 负），其余位表示数值。比如：
                    +1 的原码：00000000 00000000 00000000 00000001
                    -1 的原码：10000000 00000000 00000000 00000001
                    但原码有两个问题：一是 +0 和 -0 并存（00000000 和 10000000），二是加减法需要区分符号，运算效率低。
            二、补码：Java 为了解决原码的问题，规定所有整数都以补码形式存储和运算，补码的规则是：
                    正数的补码 = 原码（和正数本身完全一致）；
                    负数的补码 = 其绝对值的原码按位取反 + 1（也叫 “反码 + 1”）；
                    补码的最高位依然是符号位（0 = 正，1 = 负）。

            1、先明确目标：求补码 11111111 11111111 11111111 11111111 对应的十进制值；
            2、因为补码最高位是 1，所以这是一个负数，需要先把补码还原为原码，运算规则（逆运算）：补码 - 1 → 按位取反 → 原码：
               2.1、补码-1   11111111 11111111 11111111 11111110（反码）；
               2.2、按位取反  00000000 00000000 00000000 00000001（绝对值的原码，即 1）；
               2.3、结合符号位（补码最高位是 1），最终值为 -1。
            3、正向验证结果：-1 的补码就是全 1；
               3.1、-1 的绝对值是 1，原码为 00000000 00000000 00000000 00000001；
               3.2、按位取反得到反码：      11111111 11111111 11111111 11111110；
               3.3、反码加 1 得到补码：     11111111 11111111 11111111 11111111；
             */

            // 负数左移
            // d             // 11100000 00000000 00000000 00000000 = -536870912
            int l = d << 1;  // 11000000 00000000 00000000 00000000 = -1073741824
            int m = d << 2;  // 10000000 00000000 00000000 00000000 = -2147483648
//            int o = d << 3;  // 0
            System.out.println(Integer.toBinaryString(l) + " = " + l);
            System.out.println(Integer.toBinaryString(m) + " = " + m);

            // 无符号的右移运算，它的特点是不管符号位，右移后高位总是补 0
            // 因此，对一个负数进行 >>> 右移，它会变成正数，原因是最高位的 1 变成了 0
            // d             // 11100000 00000000 00000000 00000000 = -536870912
            int p = d >>> 1; // 01110000 00000000 00000000 00000000 = 1879048192
            System.out.println(Integer.toBinaryString(p) + " = " + p);
        }

        /**
         * 位运算
         * <p>
         * 位运算是按位（bit）进行与、或、非和异或的运算。
         * <ul>
         *     <li>与运算 &，两个数同时为 1，结果才为 1</li>
         *     <li>或运算 |，任意一个数为 1，结果就为 1</li>
         *     <li>非运算 ~，将 0 和 1 互换</li>
         *     <li>异或运算 ^，两个数不同时为 1，否则为 0</li>
         * </ul>
         */
        static void bitOperation() {
            // Java 没有单个 bit 的数据类型。在 Java 中，对两个整数进行位运算，实际上就是按位对齐，然后依次对每一位进行运算。
            /*
            与运算，简易示例：
            n = 0 & 0; // 0
            n = 1 & 0; // 0
            n = 0 & 1; // 0
            n = 1 & 1; // 1
            */
            int i = 167776589; //   00001010 00000000 00010001 01001101 // 10.0.17.77
            int j = 167776512; //   00001010 00000000 00010001 00000000 // 10.0.17.0
            // & ----------------------------------- // 通过 & 运算，可以快速判断一个 IP 是否在给定的网段内
            //   00001010 00000000 00010001 00000000 // 10.0.17.0
            int ij = i & j;
            System.out.println(Integer.toBinaryString(ij) + " = " + ij);

            /*
            或运算，简易示例：
            n = 0 | 0; // 0
            n = 0 | 1; // 1
            n = 1 | 0; // 1
            n = 1 | 1; // 1
            */

            // 非运算
            //             00000000 00000000 00000000 00000000 = 0
            //           ~ -----------------------------------
            int n = ~0; // 11111111 11111111 11111111 11111111 = -1
            System.out.println(Integer.toBinaryString(n) + " = " + n);
            //             00000000 00000000 00000000 00000001 = 1
            //           ~ -----------------------------------
            n = ~1; //     11111111 11111111 11111111 11111110 = -2
            System.out.println(Integer.toBinaryString(n) + " = " + n);

            /*
            异或运算，简易示例：
            n = 0 ^ 0; // 0
            n = 0 ^ 1; // 1
            n = 1 ^ 0; // 1
            n = 1 ^ 1; // 0
            */
        }

        /**
         * 运算优先级
         * <p>
         * 运算优先级从高到低依次是：
         * <ol>
         *     <li>()</li>
         *     <li>!、~、++、--</li>
         *     <li>*、/、%</li>
         *     <li>+、-</li>
         *     <li>>>、<<、>>></li>
         *     <li>&</li>
         *     <li>|</li>
         *     <li>+=、-=、*=、/=</li>
         * </ol>
         * 记不住也没关系，只需要加括号就可以保证运算的优先级正确。
         */
        static void operationalPriority() {
            System.out.println("此方法无执行内容，通过注释了解即可");
        }

        /**
         * 类型提升与强制转型
         * <p>
         * 在运算过程中，如果参与运算的两个数类型不一致，那么计算结果为较大类型的整型。
         */
        static void typePromotionAndCoercion() {
            // 例如，short 和 int 计算，结果总是 int，原因是 short 首先自动被转型为 int
            short s = 1234;
            int i = 12345;
            int x = s + i; // s 自动转型为 int
            // short y = s + i; // 编译错误!
            System.out.println(x);

            // 强制转型，⚠️强制转型的结果很可能是错的。
            short z = (short) i;
            System.out.println(z);
            // 要注意，超出范围的强制转型会得到错误的结果，原因是转型时，int 的两个高位字节直接被扔掉，仅保留了低位的两个字节
            int i1 = 1234567;      // 00000000 00010010 11010110 10000111
            short s1 = (short) i1; // -10617            11010110 10000111  提取低 16 位，2 字节
            // 反码 = 补码减1                             11010110 10000110
            // 按位取反                                   00101001 01111001 绝对值的原码，等于 10617
            // 结合符号位（补码最高位是 1），                                          最终值为 -10617
            System.out.println(Integer.toBinaryString(s1) + " = " + s1);
        }
    }
}

